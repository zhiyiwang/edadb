
#define EDADB_DEBUG 1 

namespace edadb{

//// utility functions




template<class T>
struct SqlString {
private:

//    struct UpdateRow {
//    private:
//        std::vector<std::string>& vec;
//        std::string part;
//
//    public:
//        UpdateRow(std::vector<std::string>& vec) : vec(vec) {}
//
//        template <typename O>
//        void operator()(O const& x)
//        {
//            part = "";
//            if (!vec.empty()) {
//                part = ",";
//            }
//            part += x.second + " = ";
//            vec.push_back(part);
//        }
//    };
//
//
//    struct UpdateRowVal {
//    private:
//        std::vector<std::string>& vec;
//        std::string part;
//    public:
//        UpdateRowVal(std::vector<std::string>& vec) : vec(vec) {}
//    
//        template <typename S>
//        std::string add_quotaion(S const& x)
//        {
//            return std::to_string(x);
//        }
//
//        std::string add_quotaion(std::string const& x)
//        {
//            return "\'" + x + "\'";
//        }
//
//        template <typename O>
//        void operator()(O* x)
//        {
//            part = "";
//            part += std::to_string(*x);
//            vec.push_back(part);
//        }
//
//        // template<typename std::string>
//        void operator()(std::string * x)
//        {
//            part = "";
//            part += add_quotaion(*x);
//            vec.push_back(part);
//        }
//    };
//
public:
//    static std::string const& createTableStrSubObj(const std::string prefix) { // create_table_str
//        static const auto vecs = TypeMetaData<T>::tuple_type_pair();
//        static std::string sql;
//        if (sql.empty()) {
//            auto p = new SqlString<T>::CTSOForeachHelper(sql,prefix); //CTSOForeachHelper
//            boost::fusion::for_each(vecs, *p);
//        }
//        return sql;
//    }

//    static std::string const& dropTableStr() {
//        static const std::string sql = "DROP TABLE IF EXISTS \"{}\"";
//        return sql;
//    }

   
    static std::string const& selectRowStrPK(std::string pkVal) {
        static const auto vecs = TypeMetaData<T>::tuple_type_pair();
        auto &first_pair = boost::fusion::at_c<0>(vecs);
        static const std::string sql = "SELECT * FROM \"{}\" where "
        + first_pair.second + " = " + pkVal;
        return sql;
    }

};

// soci get each member of the object
template<typename TA, bool IsComposite>
struct GetAllObjectsImpl {
    inline static void impl(TA& x, const soci::row& row, const std::string& member_name/*, const std::string& oid_ref*/) {
        x = row.get<typename ConvertCPPTypeToSupportType<TA>::type>(member_name);
    }
};

template<typename T>
struct GetAllObjects {
    private:
        const soci::row& _row;
        const std::vector<std::string>& _member_names;
        int _count;

    public:
        GetAllObjects(const soci::row& row) :_row(row),
            _member_names(TypeMetaData<T>::member_names()), _count(0) {
        }

        template <typename O> 
        void operator()(O& x){

            const std::string& member_name = _member_names.at(_count);
            // std::cout<<member_name<<"\n";
            
            using SupportType = typename ConvertCPPTypeToSupportType<typename std::remove_pointer<O>::type>::type;
            // std::cout<<"name = "<<typeid(x).name()<<"\n";
            *x = _row.get<SupportType>(member_name);
            _count++;
        }
    };




class DbBackend : public Singleton<DbBackend> {
    private:
        soci::session _sql_session;
    public:
        bool connect(std::string const &connect_str){
            const auto backend_factory = soci::sqlite3;
            _sql_session.open(backend_factory, connect_str);
            return true;
        }

        soci::session &session(){ // & return the original object
            return _sql_session;
        }
};







template<typename T>
    class DbMap {
      public:
        //Members
        std::string table_name;
        std::string select_header;
        
      public:
        static bool connectToDb(const std::string& db_connect_str); 
        void setTableName(std::string tab_name){table_name = tab_name;}
        bool createTable(std::string tab_name);
        bool insertToDb(T *obj);
        bool deleteFromDb(T *obj);
        bool updateDb(T *obj);
        bool selectFromDb(std::vector<T> *vec, std::string where_str = "");
        template<typename Q>
        bool selectWithPK(Q PK_val, T *obj);
    };

    template<typename T>
    bool DbMap<T>::connectToDb(const std::string& db_connect_str){
        auto ret = DbBackend::i().connect(db_connect_str);
        return ret;
    }

    template<typename T> 
    bool DbMap<T>::createTable(std::string tab_name){
        table_name = tab_name;
        const static std::string sql = fmt::format(SqlString<T>::createTableStr(), table_name);
        #ifdef EDADB_DEBUG
            std::cout<<sql<<"\n";
        #endif
        try {
            DbBackend::i().session() << sql;
            select_header = fmt::format(SqlString<T>::selectRowStr(),table_name);
            return true;
        }
        catch (std::exception const & e) {
            std::cerr << "createTable: " << e.what() << std::endl;
            return false;
        }
    }

    template<typename T>
    bool DbMap<T>::insertToDb(T *obj){
        SqlString<T> sql_string;
        const std::string sql = fmt::format(sql_string.insertRowStr(obj), table_name);
        #ifdef EDADB_DEBUG
            std::cout<<"insertToDb sql: "<<sql<<"\n";
        #endif
        try{
            DbBackend::i().session()<<sql; //boost 
            return true;
        }
        catch (std::exception const& e) {
            std::cerr << "insertToDb: " << e.what() << "\n";
            return false;
        }
    }

    template<typename T>
    bool DbMap<T>::deleteFromDb(T *obj){
        SqlString<T> sql_string;
        const std::string sql = fmt::format(sql_string.deleteRowStr(obj), table_name);
        #ifdef EDADB_DEBUG
            std::cout<<sql<<"\n";
        #endif
        try {
            DbBackend::i().session() << sql;
            std::cout<<"Delete it!\n";
            return true;
        }
        catch (std::exception const & e) {
            std::cerr << "deleteObj: " << e.what() << "\n";
            return false;
        }
    }

    template<typename T>
    bool DbMap<T>::updateDb(T *obj){
        SqlString<T> sql_string;
        const std::string sql = fmt::format(sql_string.updateRowStr(obj),table_name);
        #ifdef EDADB_DEBUG
            std::cout<<sql<<"\n";
        #endif
        try {
            DbBackend::i().session() << sql;
            return true;
        }
        catch (std::exception const& e) {
            std::cerr << "updateToDb: "<< e.what() << "\n";
            return false;
        }
    }

    template<typename T>
    bool DbMap<T>::selectFromDb(std::vector<T> *vec, std::string where_str){
        std::string sql;
        if(where_str.size() > 0) 
            sql = select_header + "where "+ where_str; 
        else 
            sql = select_header;

        try {
            std::cout<<sql<<std::endl;
            soci::rowset<soci::row>rows = (DbBackend::i().session().prepare << sql);
            vec->clear();
            for(soci::rowset<soci::row>::const_iterator row_itr = rows.begin();row_itr != rows.end();++row_itr){
                auto const& row = *row_itr;
                T *a = new T;
                auto vals = TypeMetaData<T>::getVal(a);
                boost::fusion::for_each(vals,GetAllObjects<T>(row));
                vec->emplace_back(std::move(*a));
            }
            return true;
        }
        catch (std::exception const& e) {
            std::cerr << "selectFromDb: "<< e.what() << "\n";
            return false;
        }
    }

    template<typename T>
    template<typename Q>
    bool DbMap<T>::selectWithPK(Q PK_val, T *obj){
        static const std::string sql = fmt::format(SqlString<T>::selectRowStrPK(std::to_string(PK_val)),table_name);
        try {
            std::cout<<sql<<std::endl;
            soci::rowset<soci::row>rows = (DbBackend::i().session().prepare << sql);
            auto const& row = *rows.begin();
            auto vals = TypeMetaData<T>::getVal(obj);
            boost::fusion::for_each(vals,GetAllObjects<T>(row));
            return true;
        }
        catch (std::exception const& e) {
            std::cerr << "selectFromDbPK: "<< e.what() << "\n";
            return false;
        }
    }
} // end of edadb namespace







